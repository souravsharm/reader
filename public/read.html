<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Reading - Text Reader</title>
    <link rel="stylesheet" href="styles.css">
</head>
<body>
    <article class="reading-container">
        <header class="reading-header">
            <a href="/" class="back-btn">‚Üê Paste New Text</a>
            <h1>Your Text</h1>
        </header>

        <main class="reading-content">
            <div id="textContent">
                <p class="loading">Loading your text...</p>
            </div>
        </main>

        <footer class="reading-footer">
            <a href="/" class="btn-secondary">‚Üê Back to Paste</a>
        </footer>
    </article>

    <script>
        /**
         * Render-time formatting only (no app refactor):
         * - Preserve blank-line paragraph grouping from pasted text.
         * - Rule 2: Quoted segments ("...") are always isolated as their own blocks.
         * - Rule 3: Standalone scene-break lines (...) are isolated with spacing.
         */
        function reconstructParagraphs(text) {
            if (!text || !text.trim()) {
                return '<p class="no-text">No text available. <a href="/">Go back</a> and paste some text.</p>';
            }

            // Normalize line endings
            text = text.replace(/\r\n/g, '\n').replace(/\r/g, '\n');
            text = text.trim();

            // Preserve original paragraph grouping: blank-line separated blocks.
            // Also tolerate whitespace-only "blank" lines.
            const rawParagraphs = text.split(/\n[ \t]*\n+/);

            const out = [];
            let currentGroupBlocks = [];

            const flushGroup = () => {
                if (currentGroupBlocks.length === 0) return;
                out.push(renderParagraphGroup(currentGroupBlocks));
                currentGroupBlocks = [];
            };

            for (const rawPara of rawParagraphs) {
                const para = rawPara.trim();
                if (!para) continue;

                // A raw paragraph may still contain multiple lines; isolate scene breaks that
                // appear as their own line within the paragraph.
                const lines = para.split('\n');
                const textLines = [];

                const flushTextLinesIntoGroup = () => {
                    if (textLines.length === 0) return;
                    const joined = textLines.join(' ').replace(/\s+/g, ' ').trim();
                    textLines.length = 0;
                    if (!joined) return;
                    currentGroupBlocks.push(...splitIntoQuoteAndProseBlocks(joined));
                };

                for (const line of lines) {
                    if (isSceneBreakLine(line)) {
                        // Rule 3: scene break must not merge with surrounding prose/quotes.
                        flushTextLinesIntoGroup();
                        flushGroup();
                        out.push(renderSceneBreak());
                        continue;
                    }
                    if (line.trim().length === 0) continue;
                    textLines.push(line.trim());
                }

                flushTextLinesIntoGroup();
                // End of original paragraph group.
                flushGroup();
            }

            flushGroup();
            return out.join('\n');
        }

        /**
         * Rule 3 helper: line is exactly "..." (ignoring surrounding whitespace).
         */
        function isSceneBreakLine(line) {
            return /^\s*\.{3}\s*$/.test(line);
        }

        /**
         * Rule 2: split into prose/quote blocks so quotes never share a line with prose.
         * Example: '"ram"  "sham" I think' -> ['"ram"', '"sham"', 'I think']
         *
         * Defensive behavior:
         * - Only isolates properly paired quotes ("..."). Unmatched quotes are left as prose.
         * - Does not split normal prose except around quotes.
         */
        function splitIntoQuoteAndProseBlocks(paragraphText) {
            const blocks = [];

            // Match ASCII double quotes with no newline inside the quoted segment.
            // This avoids runaway matches across large sections.
            const quoteRe = /"[^"\n]*"/g;

            let lastIndex = 0;
            let match;

            while ((match = quoteRe.exec(paragraphText)) !== null) {
                const before = paragraphText.slice(lastIndex, match.index).trim();
                if (before) blocks.push({ type: 'prose', text: before });

                const quoted = match[0].trim();
                if (quoted) blocks.push({ type: 'quote', text: quoted });

                lastIndex = quoteRe.lastIndex;
            }

            const after = paragraphText.slice(lastIndex).trim();
            if (after) blocks.push({ type: 'prose', text: after });

            if (blocks.length === 0 && paragraphText.trim()) {
                blocks.push({ type: 'prose', text: paragraphText.trim() });
            }

            return blocks;
        }

        function renderParagraphGroup(blocks) {
            // Keep group semantics but allow multiple blocks inside.
            // Safari Reader will still see <p> and <blockquote> as readable content.
            const inner = blocks
                .map((b) => {
                    if (b.type === 'quote') {
                        return `<blockquote class="quote"><p>${escapeHtml(b.text)}</p></blockquote>`;
                    }
                    return `<p class="prose">${escapeHtml(b.text)}</p>`;
                })
                .join('\n');

            return `<div class="para-group">\n${inner}\n</div>`;
        }

        function renderSceneBreak() {
            // Render as its own block with CSS-controlled spacing.
            return '<p class="scene-break">...</p>';
        }

        /**
         * Escape HTML to prevent XSS attacks
         */
        function escapeHtml(text) {
            const div = document.createElement('div');
            div.textContent = text;
            return div.innerHTML;
        }

        /**
         * Add text statistics for debugging
         */
        function analyzeText(text) {
            const stats = {
                length: text.length,
                lines: text.split('\n').length,
                paragraphs: text.split(/\n\n+/).length,
                words: text.split(/\s+/).length
            };
            console.log('üìä Text Analysis:', stats);
            return stats;
        }

        async function loadText() {
            try {
                const response = await fetch('/get-text');
                const data = await response.json();
                
                const textContent = document.getElementById('textContent');
                
                if (data.text && data.text.trim()) {
                    analyzeText(data.text);
                    const html = reconstructParagraphs(data.text);
                    textContent.innerHTML = html;
                    console.log('‚úÖ Text rendered successfully');
                } else {
                    textContent.innerHTML = '<p class="no-text">No text available. <a href="/">Go back</a> and paste some text.</p>';
                }
            } catch (error) {
                console.error('‚ùå Error:', error);
                document.getElementById('textContent').innerHTML = 
                    '<p class="error">Failed to load text. <a href="/">Try again</a></p>';
            }
        }

        loadText();
    </script>
</body>
</html>
