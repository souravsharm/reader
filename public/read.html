<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Reading - Text Reader</title>
    <link rel="stylesheet" href="styles.css">
</head>
<body>
    <article class="reading-container">
        <header class="reading-header">
            <a href="/" class="back-btn">‚Üê Paste New Text</a>
            <h1>Your Text</h1>
        </header>

        <main class="reading-content">
            <div id="textContent">
                <p class="loading">Loading your text...</p>
            </div>
        </main>

        <footer class="reading-footer">
            <a href="/" class="btn-secondary">‚Üê Back to Paste</a>
        </footer>
    </article>

    <script>
        /**
         * Smart Paragraph Reconstruction Algorithm
         * Handles various text formatting scenarios from copy-paste operations
         */
        function reconstructParagraphs(text) {
            if (!text || !text.trim()) {
                return '<p class="no-text">No text available. <a href="/">Go back</a> and paste some text.</p>';
            }

            // Normalize line endings (handle Windows \r\n, Mac \r, Unix \n)
            text = text.replace(/\r\n/g, '\n').replace(/\r/g, '\n');

            // Remove excessive whitespace but preserve intentional breaks
            text = text.trim();

            // Strategy 1: Check if text has clear double-newline paragraphs
            const hasDoubleNewlines = /\n\n+/.test(text);
            
            if (hasDoubleNewlines) {
                // Good formatting detected - split on double newlines
                return text
                    .split(/\n\n+/)
                    .map(p => p.trim())
                    .filter(p => p.length > 0)
                    .map(p => {
                        // Replace single newlines within paragraphs with spaces
                        // This handles wrapped text within a paragraph
                        const cleaned = p.replace(/\n/g, ' ').replace(/\s+/g, ' ');
                        return `<p>${escapeHtml(cleaned)}</p>`;
                    })
                    .join('');
            }

            // Strategy 2: Poor formatting - use heuristics to detect paragraphs
            const lines = text.split('\n').map(l => l.trim()).filter(l => l.length > 0);
            const paragraphs = [];
            let currentParagraph = [];

            for (let i = 0; i < lines.length; i++) {
                const line = lines[i];
                const nextLine = lines[i + 1];

                currentParagraph.push(line);

                // Detect paragraph end using multiple heuristics:
                const endsWithPunctuation = /[.!?]$/.test(line);
                const isShortLine = line.length < 50; // Likely a deliberate break
                const nextStartsCapital = nextLine && /^[A-Z"']/.test(nextLine);
                const isVeryLong = currentParagraph.join(' ').length > 500;

                // End paragraph if:
                // 1. Line ends with punctuation AND next line starts with capital
                // 2. Current line is short (likely intentional break)
                // 3. Current paragraph is very long (safety limit)
                // 4. This is the last line
                const shouldEndParagraph = 
                    (endsWithPunctuation && nextStartsCapital) ||
                    (isShortLine && nextStartsCapital) ||
                    isVeryLong ||
                    i === lines.length - 1;

                if (shouldEndParagraph) {
                    const paragraphText = currentParagraph.join(' ').trim();
                    if (paragraphText.length > 0) {
                        paragraphs.push(paragraphText);
                    }
                    currentParagraph = [];
                }
            }

            // Fallback: If heuristics produced too few paragraphs, split more aggressively
            if (paragraphs.length < 3 && text.length > 1000) {
                // Split on sentence endings followed by capital letters
                return text
                    .split(/([.!?]+\s+)(?=[A-Z"'])/)
                    .reduce((acc, part, i, arr) => {
                        // Combine sentence with its punctuation
                        if (i % 2 === 0 && arr[i + 1]) {
                            acc.push(part + arr[i + 1]);
                        } else if (i % 2 === 0) {
                            acc.push(part);
                        }
                        return acc;
                    }, [])
                    .map(p => p.trim())
                    .filter(p => p.length > 20) // Filter out very short fragments
                    .map((p, i, arr) => {
                        // Group every 3-5 sentences into a paragraph
                        if (i % 4 === 0) {
                            const group = arr.slice(i, i + 4).join(' ');
                            return `<p>${escapeHtml(group)}</p>`;
                        }
                        return '';
                    })
                    .filter(p => p.length > 0)
                    .join('');
            }

            // Return the heuristically detected paragraphs
            return paragraphs
                .map(p => `<p>${escapeHtml(p)}</p>`)
                .join('');
        }

        /**
         * Escape HTML to prevent XSS attacks
         */
        function escapeHtml(text) {
            const div = document.createElement('div');
            div.textContent = text;
            return div.innerHTML;
        }

        /**
         * Add text statistics for debugging (optional)
         */
        function analyzeText(text) {
            const stats = {
                length: text.length,
                lines: text.split('\n').length,
                doubleNewlines: (text.match(/\n\n+/g) || []).length,
                paragraphs: text.split(/\n\n+/).length,
                words: text.split(/\s+/).length
            };
            console.log('üìä Text Analysis:', stats);
            return stats;
        }

        async function loadText() {
            try {
                const response = await fetch('/get-text');
                const data = await response.json();
                
                const textContent = document.getElementById('textContent');
                
                if (data.text && data.text.trim()) {
                    // Analyze the text structure (for debugging)
                    analyzeText(data.text);
                    
                    // Reconstruct paragraphs intelligently
                    const html = reconstructParagraphs(data.text);
                    textContent.innerHTML = html;
                    
                    // Log success
                    console.log('‚úÖ Text rendered successfully');
                } else {
                    textContent.innerHTML = '<p class="no-text">No text available. <a href="/">Go back</a> and paste some text.</p>';
                }
            } catch (error) {
                console.error('‚ùå Error:', error);
                document.getElementById('textContent').innerHTML = 
                    '<p class="error">Failed to load text. <a href="/">Try again</a></p>';
            }
        }

        // Load text when page loads
        loadText();
    </script>
</body>
</html>
