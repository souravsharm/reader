<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Reading - Text Reader</title>
    <link rel="stylesheet" href="styles.css">
</head>
<body>
    <article class="reading-container">
        <header class="reading-header">
            <a href="/" class="back-btn">‚Üê Paste New Text</a>
            <h1>Your Text</h1>
        </header>

        <main class="reading-content">
            <div id="textContent">
                <p class="loading">Loading your text...</p>
            </div>
        </main>

        <footer class="reading-footer">
            <a href="/" class="btn-secondary">‚Üê Back to Paste</a>
        </footer>
    </article>

    <script>
        /**
         * Smart Paragraph Reconstruction with Formatting Rules
         */
        function reconstructParagraphs(text) {
            if (!text || !text.trim()) {
                return '<p class="no-text">No text available. <a href="/">Go back</a> and paste some text.</p>';
            }

            // Normalize line endings
            text = text.replace(/\r\n/g, '\n').replace(/\r/g, '\n');
            text = text.trim();

            // Apply formatting rules
            text = applyFormattingRules(text);

            // Strategy 1: Check if text has clear double-newline paragraphs
            const hasDoubleNewlines = /\n\n+/.test(text);
            
            if (hasDoubleNewlines) {
                return text
                    .split(/\n\n+/)
                    .map(p => p.trim())
                    .filter(p => p.length > 0)
                    .map(p => {
                        // Check if this is a scene break
                        if (p === '...') {
                            return '<p class="scene-break">...</p>';
                        }
                        const cleaned = p.replace(/\n/g, ' ').replace(/\s+/g, ' ');
                        return `<p>${escapeHtml(cleaned)}</p>`;
                    })
                    .join('');
            }

            // Strategy 2: Heuristics for poor formatting
            const lines = text.split('\n').map(l => l.trim()).filter(l => l.length > 0);
            const paragraphs = [];
            let currentParagraph = [];

            for (let i = 0; i < lines.length; i++) {
                const line = lines[i];
                const nextLine = lines[i + 1];

                currentParagraph.push(line);

                const endsWithPunctuation = /[.!?]$/.test(line);
                const isShortLine = line.length < 50;
                const nextStartsCapital = nextLine && /^[A-Z"']/.test(nextLine);
                const isVeryLong = currentParagraph.join(' ').length > 500;

                const shouldEndParagraph = 
                    (endsWithPunctuation && nextStartsCapital) ||
                    (isShortLine && nextStartsCapital) ||
                    isVeryLong ||
                    i === lines.length - 1;

                if (shouldEndParagraph) {
                    const paragraphText = currentParagraph.join(' ').trim();
                    if (paragraphText.length > 0) {
                        paragraphs.push(paragraphText);
                    }
                    currentParagraph = [];
                }
            }

            if (paragraphs.length < 3 && text.length > 1000) {
                return text
                    .split(/([.!?]+\s+)(?=[A-Z"'])/)
                    .reduce((acc, part, i, arr) => {
                        if (i % 2 === 0 && arr[i + 1]) {
                            acc.push(part + arr[i + 1]);
                        } else if (i % 2 === 0) {
                            acc.push(part);
                        }
                        return acc;
                    }, [])
                    .map(p => p.trim())
                    .filter(p => p.length > 20)
                    .map((p, i, arr) => {
                        if (i % 4 === 0) {
                            const group = arr.slice(i, i + 4).join(' ');
                            return `<p>${escapeHtml(group)}</p>`;
                        }
                        return '';
                    })
                    .filter(p => p.length > 0)
                    .join('');
            }

            return paragraphs
                .map(p => {
                    if (p === '...') {
                        return '<p class="scene-break">...</p>';
                    }
                    return `<p>${escapeHtml(p)}</p>`;
                })
                .join('');
        }

        /**
         * Apply formatting rules:
         * Rule 1: Separate consecutive quoted strings
         * Rule 2: Isolate ellipsis scene breaks
         */
        function applyFormattingRules(text) {
            // RULE 2: Ellipsis as scene break
            // Find standalone "..." and ensure it has empty lines around it
            text = text.replace(/^\.\.\.$/gm, '\n\n...\n\n');
            text = text.replace(/^\s*‚Ä¶\s*$/gm, '\n\n...\n\n');
            
            // Clean up any excessive newlines created (max 2)
            text = text.replace(/\n{3,}/g, '\n\n');
            
            // RULE 1: Successive quoted lines
            // Pattern: closing quote followed by opening quote (with optional whitespace/newline)
            // Matches: "text" "text" or "text"\n"text"
            text = text.replace(/(["""])(\s*\n?\s*)(["""])/g, function(match, closeQuote, middle, openQuote) {
                // If there's already a double newline, keep it
                if (middle.includes('\n\n')) {
                    return closeQuote + middle + openQuote;
                }
                // Otherwise, add double newline for separation
                return closeQuote + '\n\n' + openQuote;
            });
            
            return text;
        }

        /**
         * Escape HTML to prevent XSS attacks
         */
        function escapeHtml(text) {
            const div = document.createElement('div');
            div.textContent = text;
            return div.innerHTML;
        }

        /**
         * Add text statistics for debugging
         */
        function analyzeText(text) {
            const stats = {
                length: text.length,
                lines: text.split('\n').length,
                doubleNewlines: (text.match(/\n\n+/g) || []).length,
                paragraphs: text.split(/\n\n+/).length,
                words: text.split(/\s+/).length
            };
            console.log('üìä Text Analysis:', stats);
            return stats;
        }

        async function loadText() {
            try {
                const response = await fetch('/get-text');
                const data = await response.json();
                
                const textContent = document.getElementById('textContent');
                
                if (data.text && data.text.trim()) {
                    analyzeText(data.text);
                    const html = reconstructParagraphs(data.text);
                    textContent.innerHTML = html;
                    console.log('‚úÖ Text rendered successfully');
                } else {
                    textContent.innerHTML = '<p class="no-text">No text available. <a href="/">Go back</a> and paste some text.</p>';
                }
            } catch (error) {
                console.error('‚ùå Error:', error);
                document.getElementById('textContent').innerHTML = 
                    '<p class="error">Failed to load text. <a href="/">Try again</a></p>';
            }
        }

        loadText();
    </script>
</body>
</html>
