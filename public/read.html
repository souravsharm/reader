<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Reading - Text Reader</title>
    <link rel="stylesheet" href="styles.css">
</head>
<body>
    <article class="reading-container">
        <header class="reading-header">
            <a href="/" class="back-btn">‚Üê Paste New Text</a>
            <h1>Your Text</h1>
        </header>

        <main class="reading-content">
            <div id="textContent">
                <p class="loading">Loading your text...</p>
            </div>
        </main>

        <footer class="reading-footer">
            <a href="/" class="btn-secondary">‚Üê Back to Paste</a>
        </footer>
    </article>

    <script>
        /**
         * Format text with two rules:
         * Rule A: Quotes always on their own lines
         * Rule B: Scene breaks "..." isolated with blank lines
         */
        function reconstructParagraphs(text) {
            if (!text || !text.trim()) {
                return '<p class="no-text">No text available. <a href="/">Go back</a> and paste some text.</p>';
            }

            // Normalize line endings
            text = text.replace(/\r\n/g, '\n').replace(/\r/g, '\n');
            text = text.trim();

            // Split into paragraphs (preserve original blank-line grouping)
            const paragraphs = text.split(/\n\n+/);
            const htmlParts = [];

            for (let para of paragraphs) {
                para = para.trim();
                if (!para) continue;

                // RULE B: Check if this is a scene break (exactly "...")
                if (/^\s*\.{3}\s*$/.test(para) || /^\s*‚Ä¶\s*$/.test(para)) {
                    htmlParts.push('<p class="scene-break">...</p>');
                    continue;
                }

                // RULE A: Extract quotes and non-quote text as separate lines
                const lines = extractQuotesAndText(para);
                
                if (lines.length === 0) continue;

                // Render paragraph with lines separated by <br>
                const linesHtml = lines
                    .map(line => escapeHtml(line))
                    .join('<br>\n');
                
                htmlParts.push(`<p>${linesHtml}</p>`);
            }

            return htmlParts.join('\n');
        }

        /**
         * Extract quotes and non-quote text as separate lines
         * Example: '"ram" "sham" I think' ‚Üí ['"ram"', '"sham"', 'I think']
         */
        function extractQuotesAndText(text) {
            const lines = [];
            
            // Pattern matches quoted strings (both straight and curly quotes)
            const quotePattern = /(["""][^"""]*["""])/g;
            let lastIndex = 0;
            let match;

            while ((match = quotePattern.exec(text)) !== null) {
                // Text before the quote
                if (match.index > lastIndex) {
                    const before = text.substring(lastIndex, match.index).trim();
                    if (before) {
                        lines.push(before);
                    }
                }

                // The quote itself
                const quote = match[1].trim();
                if (quote) {
                    lines.push(quote);
                }

                lastIndex = quotePattern.lastIndex;
            }

            // Text after the last quote
            if (lastIndex < text.length) {
                const after = text.substring(lastIndex).trim();
                if (after) {
                    lines.push(after);
                }
            }

            // If no quotes found, return the whole text as one line
            if (lines.length === 0 && text.trim()) {
                lines.push(text.trim());
            }

            return lines;
        }

        /**
         * Escape HTML to prevent XSS attacks
         */
        function escapeHtml(text) {
            const div = document.createElement('div');
            div.textContent = text;
            return div.innerHTML;
        }

        /**
         * Add text statistics for debugging
         */
        function analyzeText(text) {
            const stats = {
                length: text.length,
                lines: text.split('\n').length,
                paragraphs: text.split(/\n\n+/).length,
                words: text.split(/\s+/).length
            };
            console.log('üìä Text Analysis:', stats);
            return stats;
        }

        async function loadText() {
            try {
                const response = await fetch('/get-text');
                const data = await response.json();
                
                const textContent = document.getElementById('textContent');
                
                if (data.text && data.text.trim()) {
                    analyzeText(data.text);
                    const html = reconstructParagraphs(data.text);
                    textContent.innerHTML = html;
                    console.log('‚úÖ Text rendered successfully');
                } else {
                    textContent.innerHTML = '<p class="no-text">No text available. <a href="/">Go back</a> and paste some text.</p>';
                }
            } catch (error) {
                console.error('‚ùå Error:', error);
                document.getElementById('textContent').innerHTML = 
                    '<p class="error">Failed to load text. <a href="/">Try again</a></p>';
            }
        }

        loadText();
    </script>
</body>
</html>
